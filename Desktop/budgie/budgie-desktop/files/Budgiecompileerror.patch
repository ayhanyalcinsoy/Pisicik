--- BudgiePanelold.vala	2014-09-02 01:44:57.000000000 +0300
+++ ./panel/BudgiePanel.vala	2014-10-23 13:49:27.712154376 +0300
@@ -10,14 +10,47 @@
  */
 
 /* These exist for theme integration. */
-public class PanelToplevel : Budgie.Panel {
+public class PanelToplevel : Gtk.Bin
+{
 
     public PanelToplevel()
     {
-        base();
     }
 }
-public class PanelApplet : Gtk.Bin {
+public class PanelApplet : Gtk.Bin
+{
+}
+public class AppletHolder : Gtk.Bin
+{
+
+    public bool gnome_mode { public get; public set ; }
+
+    public AppletHolder()
+    {
+        gnome_mode = true;
+    }
+
+#if HAVE_GTK313
+    protected override Gtk.WidgetPath get_path_for_child(Gtk.Widget child)
+    {
+        Gtk.WidgetPath path = base.get_path_for_child(child);
+#else
+    protected override weak Gtk.WidgetPath get_path_for_child(Gtk.Widget child)
+    {
+        unowned Gtk.WidgetPath path = base.get_path_for_child(child);
+#endif
+        if (gnome_mode) {
+            path.iter_set_object_type(0, typeof(PanelToplevel));
+            for (int i=0; i<path.length(); i++) {
+                if (path.iter_get_object_type(i) == typeof(AppletHolder)) {
+                    path.iter_set_object_type(i, typeof(PanelApplet));
+                    break;
+                }
+            }
+        }
+
+        return path;
+    }
 }
 
 namespace Budgie
@@ -74,12 +107,62 @@
 public class PanelShadow : Gtk.Window
 {
 
-    public PanelShadow()
+    protected Budgie.Panel? panel;
+    public static const int SHADOW_SIZE = 4;
+
+    public PanelShadow(Budgie.Panel? panel)
     {
         decorated = false;
         skip_taskbar_hint = true;
         skip_pager_hint = true;
         type_hint = Gdk.WindowTypeHint.DOCK;
+
+        resizable = false;
+
+        this.panel = panel;
+    }
+
+    /* The next methods are all designed to force a specific size only! */
+    public override void get_preferred_width(out int min, out int natural)
+    {
+        var width = panel.primary_monitor_rect.width;
+        if (panel.position == PanelPosition.LEFT || panel.position == PanelPosition.RIGHT) {
+            width = SHADOW_SIZE;
+        }
+        min = width;
+        natural = width;
+    }
+
+    public override void get_preferred_height(out int min, out int natural)
+    {
+        if (panel.position == PanelPosition.LEFT || panel.position == PanelPosition.RIGHT) {
+            min = panel.primary_monitor_rect.height;
+            natural = min;
+        } else {
+            min = SHADOW_SIZE;
+            natural = SHADOW_SIZE;
+        }
+    }
+
+    public override void get_preferred_height_for_width(int width, out int min, out int natural)
+    {
+        if (panel.position == PanelPosition.LEFT || panel.position == PanelPosition.RIGHT) {
+            min = screen.get_height();
+            natural = min;
+        } else {
+            min = SHADOW_SIZE;
+            natural = SHADOW_SIZE;
+        }
+    }
+
+    public override void get_preferred_width_for_height(int height, out int min, out int natural)
+    {
+        var width = panel.primary_monitor_rect.width;
+        if (panel.position == PanelPosition.LEFT || panel.position == PanelPosition.RIGHT) {
+            width = SHADOW_SIZE;
+        }
+        min = width;
+        natural = width;
     }
 
     public override bool draw(Cairo.Context ctx)
@@ -112,7 +195,7 @@
         }
     }
 
-    private PanelPosition position;
+    public PanelPosition position;
     private Gtk.Box master_layout;
     private Gtk.Box widgets_area;
 
@@ -133,8 +216,6 @@
     KeyFile config;
 
     Settings settings;
-    // Simply for the colourisation of the panel
-    Wnck.Screen wnck_screen;
 
     // Panel editor/preferences
     private PanelEditor prefs_dialog;
@@ -147,13 +228,28 @@
     protected bool use_shadow;
 
     private int primary_monitor;
-    private Gdk.Rectangle primary_monitor_rect;
+    public Gdk.Rectangle primary_monitor_rect;
+
+    private ulong alloc_id;
+    public int stored_x;
+    public int stored_y;
+    public int stored_height;
+    public int stored_width;
+
+    protected PanelMover mover;
+    /* Whether to draw the borders (i.e. in movement) */
+    protected bool draw_border = true;
+
+    protected Gtk.Widget? target_style;
+
+    protected bool hidden_struts = false;
 
     public Panel()
     {
         primary_monitor = screen.get_primary_monitor();
         
         screen.get_monitor_geometry(primary_monitor, out primary_monitor_rect);
+        screen.monitors_changed.connect(on_screen_changed);
 
         /* Set an RGBA visual whenever we can */
         Gdk.Visual? vis = screen.get_rgba_visual();
@@ -166,17 +262,24 @@
         resizable = false;
 
         // need a shadow. only supports bottom position right now.
-        shadow = new PanelShadow();
+        shadow = new PanelShadow(this);
         shadow.set_visual(vis);
 
         settings = new Settings("com.evolve-os.budgie.panel");
-        gnome_mode = settings.get_boolean("gnome-panel-theme-integration");
+        alloc_id = size_allocate.connect(on_size_allocate);
 
         on_settings_change("enable-shadow");
+        on_settings_change("dark-theme");
+
+        target_style = this;
 
         /* Ensure to initialise styles */
         try {
+#if HAVE_GTK313
+            File ruri = File.new_for_uri("resource://com/evolve-os/budgie/panel/style_313.css");
+#else
             File ruri = File.new_for_uri("resource://com/evolve-os/budgie/panel/style.css");
+#endif
             var prov = new Gtk.CssProvider();
             prov.load_from_file(ruri);
             Gtk.StyleContext.add_provider_for_screen(screen, prov, Gtk.STYLE_PROVIDER_PRIORITY_FALLBACK);
@@ -189,12 +292,6 @@
             stderr.printf("Unable to load styles: %s\n", e.message);
         }
 
-        // Base styling
-        if (!gnome_mode) {
-            get_style_context().add_class("budgie-panel");
-        }
-        get_style_context().remove_class("background");
-
         // simple layout
         master_layout = new Gtk.Box(Gtk.Orientation.HORIZONTAL, 0);
         add(master_layout);
@@ -203,6 +300,8 @@
         type_hint = Gdk.WindowTypeHint.DOCK;
         set_keep_above(true);
 
+        get_style_context().remove_class("background");
+
         // Initialize plugins engine
         engine = Peas.Engine.get_default();
         engine.add_search_path(module_directory, module_data_directory);
@@ -238,15 +337,13 @@
         // Right now our plugins are kinda locked in where they go. Sorry
         extset.extension_added.connect(on_extension_added);
 
-        // set up wnck
-        Wnck.set_client_type(Wnck.ClientType.PAGER);
-        wnck_screen = Wnck.Screen.get_default();
-        wnck_screen.window_opened.connect(on_window_opened);
-        wnck_screen.window_closed.connect(on_window_closed);
-        wnck_screen.active_window_changed.connect(on_active_window_changed);
 
         load_config();
 
+        on_settings_change("gnome-panel-theme-integration");
+
+        // prevent masses of size allocates
+        stored_y = stored_width = stored_height = stored_x = 0;
         master_layout.show();
         show();
 
@@ -256,12 +353,6 @@
             on_extension_added(i, ext);
         });
 
-
-        size_allocate.connect((s) => {
-            update_position();
-            set_struts();
-        });
-
         set_struts();
 
         // Horrible, but all we can do for now.
@@ -280,6 +371,77 @@
             }
             return false;
         });
+
+        add_events(Gdk.EventMask.ENTER_NOTIFY_MASK | Gdk.EventMask.LEAVE_NOTIFY_MASK);
+        mover = new PanelMover(this);
+        mover.animation_begin.connect(()=> {
+            draw_border = false;
+            queue_draw();
+            shadow.hide();
+        });
+        mover.animation_end.connect(()=> {
+            draw_border = true;
+            queue_draw();
+        });
+        mover.visibility_changed.connect((b)=> {
+            hidden_struts = !b;
+            set_struts();
+            if (b && use_shadow ) {
+                update_position();
+            }
+        });
+
+        /* First start, hide panel after a second so user actually knows
+         * where it is before it disappears.. */
+        if (settings.get_string("hide-policy") == "automatic") {
+            Timeout.add(1000, ()=> {
+                mover.hide();
+                return false;
+            });
+        }
+    }
+
+    protected void on_screen_changed()
+    {
+        screen.get_monitor_geometry(primary_monitor, out primary_monitor_rect);
+        stored_x = 0;
+        stored_y = 0;
+        stored_width = 0;
+        stored_height = 0;
+
+        queue_resize();
+    }
+
+#if HAVE_GTK313
+    protected override Gtk.WidgetPath get_path_for_child(Gtk.Widget child)
+    {
+        Gtk.WidgetPath path = base.get_path_for_child(child);
+#else
+    protected override weak Gtk.WidgetPath get_path_for_child(Gtk.Widget child)
+    {
+        unowned Gtk.WidgetPath path = base.get_path_for_child(child);
+#endif
+        if (gnome_mode) {
+            path.iter_set_object_type(0, typeof(PanelToplevel));
+        }
+
+        return path;
+    }
+
+    protected void on_size_allocate(Gtk.Allocation alloc)
+    {
+        // Only update when we *absolutely* need to.
+        if (alloc.x == stored_x && alloc.y == stored_y && alloc.width == stored_width && alloc.height == stored_height) {
+            return;
+        }
+
+        stored_x = alloc.x;
+        stored_y = alloc.y;
+        stored_width = alloc.width;
+        stored_height = alloc.height;
+
+        update_position();
+        set_struts();
     }
 
     protected void on_settings_change(string key)
@@ -306,6 +468,12 @@
             use_shadow = settings.get_boolean(key);
             update_position();
             set_struts();
+        } else if (key == "gnome-panel-theme-integration") {
+            gnome_mode = settings.get_boolean(key);
+            update_toplevel_style();
+        } else if (key == "dark-theme") {
+            this.get_settings().set_property("gtk-application-prefer-dark-theme",
+                settings.get_boolean(key));
         }
     }
 
@@ -319,7 +487,7 @@
         int pad_start = 0, pad_end = 0;
         string name = applet_info.name;
         unowned Budgie.Applet applet = applet_info.applet;
-        Gtk.Widget? target_widg;
+        AppletHolder? target_widg;
 
         try {
             if (config.has_key(name, "Pack")) {
@@ -348,8 +516,13 @@
                 }
             }
             // Deprecated in 3.12, use margin-start, margin-end in future
-            applet.margin_left = pad_start;
-            applet.margin_right = pad_end;
+            if (position == PanelPosition.TOP || position == PanelPosition.BOTTOM) {
+                applet.margin_left = pad_start;
+                applet.margin_right = pad_end;
+            } else {
+                applet.margin_top = pad_start;
+                applet.margin_bottom = pad_end;
+            }
         } catch (Error e) {
             warning("Plugin load error gaining attributes: %s", e.message);
         }
@@ -358,15 +531,12 @@
         applet.show();
 
         // Existing themes refer to PanelToplevel and PanelApplet extensively.
-        if (gnome_mode) {
-            target_widg = new PanelApplet();
-            // Ensures we don't get wnck.pager throwing a hissy fit in gnome mode
-            target_widg.set_size_request(1, 1);
-            (target_widg as PanelApplet).add(applet);
-            target_widg.show();
-        } else {
-            target_widg = applet;
-        }
+        target_widg = new AppletHolder();
+        target_widg.gnome_mode = gnome_mode;
+        // Ensures we don't get wnck.pager throwing a hissy fit in gnome mode
+        target_widg.set_size_request(1, 1);
+        (target_widg as AppletHolder).add(applet);
+        target_widg.show();
 
         if (center) {
             // not yet supported as we need checks for 3.2
@@ -387,8 +557,8 @@
         }
 
         foreach (var sprog in pack_target.get_children()) {
-            if (sprog is PanelApplet) {
-                var sprog2 = (sprog as PanelApplet).get_child() as Budgie.Applet;
+            if (sprog is AppletHolder) {
+                var sprog2 = (sprog as AppletHolder).get_child() as Budgie.Applet;
                 if (sprog2 == applet) {
                     break;
                 }
@@ -408,14 +578,22 @@
     public void applet_updated(Object o, ParamSpec p)
     {
         AppletInfo app_info = o as AppletInfo;
-        Gtk.Widget? target_widg  = gnome_mode ? app_info.applet.get_parent() : app_info.applet;
+        Gtk.Widget? target_widg  = app_info.applet.get_parent();
         Gtk.Box owner = target_widg.get_parent() as Gtk.Box;
 
         if (p.name == "pad-start") {
-            app_info.applet.margin_left = app_info.pad_start;
+            if (position == PanelPosition.TOP || position == PanelPosition.BOTTOM) {
+                app_info.applet.margin_left = app_info.pad_start;
+            } else {
+                app_info.applet.margin_top = app_info.pad_start;
+            }
         }
         if (p.name == "pad-end") {
-            app_info.applet.margin_right = app_info.pad_end;
+            if (position == PanelPosition.TOP || position == PanelPosition.BOTTOM) {
+                app_info.applet.margin_right = app_info.pad_end;
+            } else {
+                app_info.applet.margin_bottom = app_info.pad_end;
+            }
         }
         if (p.name == "position") {
             /* This is where it gets complicated.. */
@@ -482,7 +660,7 @@
     {
         AppletInfo appl = applets[name];
         // So we can actually reposition everyone
-        Gtk.Widget? target_widg = gnome_mode ? appl.applet.get_parent() : appl.applet;
+        Gtk.Widget? target_widg = appl.applet.get_parent();
         Gtk.Box? owner = target_widg.get_parent() as Gtk.Box;
         int position = appl.position;
 
@@ -494,7 +672,7 @@
         /* Unfortunately this is ugly as all shit, but what can ya do. */
         uint length = owner.get_children().length();
         foreach (var applet in applets.values) {
-            Gtk.Widget? target2 = gnome_mode ? applet.applet.get_parent() : applet.applet;
+            Gtk.Widget? target2 = applet.applet.get_parent();
             if (target2.get_parent() == owner && applet.position > position) {
                 applet.position -= 1;
             }
@@ -716,23 +894,29 @@
             return;
         }
 
+        long panel_size = intended_height;
+
+        if (hidden_struts) {
+            panel_size = 1;
+        }
+
         // Struts dependent on position
         switch (position) {
             case PanelPosition.TOP:
-                struts = { 0, 0, primary_monitor_rect.y+intended_height, 0,
+                struts = { 0, 0, primary_monitor_rect.y+panel_size, 0,
                     0, 0, 0, 0,
                     primary_monitor_rect.x, primary_monitor_rect.x+primary_monitor_rect.width,
                     0, 0
                 };
                 break;
             case PanelPosition.LEFT:
-                struts = { intended_height, 0, 0, 0,
+                struts = { panel_size, 0, 0, 0,
                     primary_monitor_rect.y, primary_monitor_rect.y+primary_monitor_rect.height, 
                     0, 0, 0, 0, 0, 0
                 };
                 break;
             case PanelPosition.RIGHT:
-                struts = { 0, intended_height, 0, 0,
+                struts = { 0, panel_size, 0, 0,
                     0, 0,
                     primary_monitor_rect.y, primary_monitor_rect.y+primary_monitor_rect.height,
                     0, 0, 0, 0
@@ -741,7 +925,7 @@
             case PanelPosition.BOTTOM:
             default:
                 struts = { 0, 0, 0, 
-                    (screen.get_height()-primary_monitor_rect.height-primary_monitor_rect.y) + intended_height,
+                    (screen.get_height()-primary_monitor_rect.height-primary_monitor_rect.y) + panel_size,
                     0, 0, 0, 0, 0, 0, 
                     primary_monitor_rect.x, primary_monitor_rect.x + primary_monitor_rect.width
                 };
@@ -760,7 +944,6 @@
         int width = get_allocated_width();
         int x = 0, y = 0;
         int pan_x = 0, pan_y = 0;
-        int pan_width = 0, pan_height = 0;
 
         string[] classes =  {
             "top",
@@ -773,54 +956,40 @@
             case PanelPosition.TOP:
                 newclass = "top";
                 y = primary_monitor_rect.y+0;
-                pan_width = width;
-                pan_height = SHADOW_SIZE;
                 pan_y = intended_height;
                 break;
             case PanelPosition.LEFT:
                 newclass = "left";
                 y = primary_monitor_rect.y+0;
-                pan_x = width - (SHADOW_SIZE/2);
-                pan_width = SHADOW_SIZE;
-                pan_height = height;
+                pan_x = width;
                 break;
             case PanelPosition.RIGHT:
                 newclass = "right";
                 x = primary_monitor_rect.x+primary_monitor_rect.width-width;
-                pan_x = x - (SHADOW_SIZE/2);
-                pan_width = SHADOW_SIZE;
-                pan_height = height;
+                pan_x = x - SHADOW_SIZE;
                 break;
             case PanelPosition.BOTTOM:
             default:
                 newclass = "bottom";
                 y = primary_monitor_rect.y+primary_monitor_rect.height-height;
-                pan_width = width;
-                pan_height = SHADOW_SIZE;
                 pan_y = y - SHADOW_SIZE;
                 break;
         }
-        if (!gnome_mode) {
-            var st = get_style_context();
-            var st2 = shadow.get_style_context();
-            foreach (var tclass in classes) {
-                if (newclass != tclass) {
-                    st.remove_class(tclass);
-                    st2.remove_class(tclass);
-                }
-            }
-            if (newclass != "") {
-                st.add_class(newclass);
-                st2.add_class(newclass);
+        var st = get_style_context();
+        var st2 = shadow.get_style_context();
+        foreach (var tclass in classes) {
+            if (newclass != tclass) {
+                st.remove_class(tclass);
+                st2.remove_class(tclass);
             }
         }
+        if (newclass != "") {
+            st.add_class(newclass);
+            st2.add_class(newclass);
+        }
 
         Gtk.Orientation orientation;
 
-        if (position != PanelPosition.BOTTOM) {
-            use_shadow = false;
-        }
-
         if (position == PanelPosition.LEFT || position == PanelPosition.RIGHT) {
             // Effectively we're now vertical. deal with it.
             orientation = Gtk.Orientation.VERTICAL;
@@ -840,16 +1009,28 @@
                         applet_info.applet.orientation_changed(orientation);
                         applet_info.applet.position_changed(position);
                         inform_size(applet_info.applet);
+
+                        applet_info.applet.freeze_notify();
+                        applet_info.applet.set_property("margin", 0);
+                        if (position == PanelPosition.TOP || position == PanelPosition.BOTTOM) {
+                            applet_info.applet.margin_left = applet_info.pad_start;
+                            applet_info.applet.margin_right = applet_info.pad_end;
+                        } else {
+                            applet_info.applet.margin_top = applet_info.pad_start;
+                            applet_info.applet.margin_bottom = applet_info.pad_end;
+                        }
+                        applet_info.applet.thaw_notify();
                     }
                 };
         }
 
+        SignalHandler.block(this, alloc_id);
         move(x,y);
+        SignalHandler.unblock(this, alloc_id);
 
         /* Move shadow too. */
         if (use_shadow) {
-            shadow.set_default_size(pan_width, pan_height);
-            shadow.set_size_request(pan_width, pan_height);
+            shadow.hide();
             shadow.move(pan_x, pan_y);
             shadow.show();
         } else {
@@ -859,16 +1040,46 @@
         queue_draw();
     }
 
+    protected void update_toplevel_style()
+    {
+        if (gnome_mode) {
+            if (target_style == this || target_style == null) {
+                target_style = new PanelToplevel();
+            }
+        } else {
+            if (target_style != this) {
+                target_style.destroy();
+            }
+            target_style = this;
+        }
+
+        // Base styling
+        if (gnome_mode) {
+            get_style_context().remove_class("budgie-panel");
+        } else {
+            get_style_context().add_class("budgie-panel");
+        }
+
+        foreach(var applet_info in applets.values) {
+            var parent = applet_info.applet.get_parent() as AppletHolder;
+            parent.gnome_mode = gnome_mode;
+        }
+
+        queue_draw();
+    }
+
     /**
      * Ensure our CSS theming is followed. In future we'll enable much more
      * in the way of customisations (background image anyone?)
      */
     public override bool draw(Cairo.Context cr)
     {
-        var st = get_style_context();
+        var st = target_style.get_style_context();
 
         st.render_background(cr, 0, 0, get_allocated_width(), get_allocated_height());
-        st.render_frame(cr, 0, 0, get_allocated_width(), get_allocated_height());
+        if (draw_border) {
+            st.render_frame(cr, 0, 0, get_allocated_width(), get_allocated_height());
+        }
 
         return base.draw(cr);
     }
@@ -958,82 +1169,12 @@
         prefs_dialog.present();
     }
 
-    /*
-     * WNCK stuff follows, simply to update the panel background
-     */
-    protected void on_window_opened(Wnck.Window window)
-    {
-        ulong id = window.state_changed.connect(on_window_state_changed);
-        window.set_data("__bid", id);
-        update_panel_state();
-    }
-
-    protected void on_window_closed(Wnck.Window window)
-    {
-        // quicker than waiting on GC.
-        ulong id = window.get_data("__bid");
-        window.disconnect(id);
-        update_panel_state();
-    }
-
-    protected void on_active_window_changed(Wnck.Window? prev_window)
-    {
-        update_panel_state();
-    }
-
-    protected void on_window_state_changed(Wnck.WindowState mask, Wnck.WindowState new_state)
-    {
-        update_panel_state();
-    }
-
-    protected void update_panel_state()
-    {
-        int wx, wy, ww, wh; // wnck out vars
-
-        if (gnome_mode) {
-            return;
-        }
-        bool havemax = false;
-        // Might not have a workspace. Shrug. Revisit if/when it becomes a problem
-        Wnck.Workspace? workspace = wnck_screen.get_active_workspace();
-        foreach (var window in wnck_screen.get_windows()) {
-            bool subvis = false;
-
-            window.get_client_window_geometry(out wx, out wy, out ww, out wh);
-
-            if (workspace != null) {
-                subvis = window.is_visible_on_workspace(workspace);
-            } else {
-                if (!window.is_minimized() && !window.is_shaded()) {
-                    subvis = true;
-                }
-            }
-            if (window.is_maximized_vertically() && subvis &&
-                // ensure that the window is fully contained within the
-                // primary monitor as maximizing a window on other
-                // monitors should not affect the shading of the bar
-                wx >= primary_monitor_rect.x &&
-                wx <= primary_monitor_rect.x + primary_monitor_rect.width &&
-                wy >= primary_monitor_rect.y &&
-                wy <= primary_monitor_rect.y + primary_monitor_rect.height
-            ) {
-                havemax = true;
-                break;
-            }
-        }
-        // Set the max-budgie-panel style, i.e. a darker panel :)
-        if (havemax) {
-            get_style_context().add_class("max-budgie-panel");
-        } else {
-            get_style_context().remove_class("max-budgie-panel");
-        }
-    }
 
     /* Inform a given applet the new maximum icon size */
     protected void inform_size(Applet applet)
     {
         /* Always remove a few pixels because icons are sensitive creatures */
-        int offset = 5;
+        int offset = 8;
         /* Maximum size */
         int height = intended_height - offset;
 
@@ -1074,12 +1215,7 @@
     {
         hold();
         if (panel == null) {
-            var settings = new Settings("com.evolve-os.budgie.panel");
-            if (settings.get_boolean("gnome-panel-theme-integration") == true) {
-                panel = new PanelToplevel();
-            } else {
-                panel = new Budgie.Panel();
-            }
+            panel = new Budgie.Panel();
             Gtk.main();
         }
         release();
